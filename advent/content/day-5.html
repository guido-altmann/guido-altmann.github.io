<div class="content-wrapper">
    <div class="content-header">
        <h2>Tag 5: Entity Framework Performance-Tipp</h2>
        <span class="day-badge">ğŸ„ 5. Dezember</span>
    </div>

    <div class="content-body">
        <p class="intro">Beim Laden von verwandten Daten gibt es drei Strategien:</p>

        <h3>ğŸ’¡ Loading-Strategien</h3>
        <ul>
            <li><strong>Eager Loading:</strong> <code>.Include(o => o.Details)</code> - lÃ¤dt alles sofort</li>
            <li><strong>Lazy Loading:</strong> Daten werden bei Bedarf geladen (Achtung: N+1 Problem!)</li>
            <li><strong>Explicit Loading:</strong> Manuelles Nachladen mit <code>.Collection().Load()</code></li>
        </ul>

        <h3>ğŸ„ Weihnachtstipp</h3>
        <p>FÃ¼r groÃŸe Datenmengen nutzen Sie <code>AsNoTracking()</code> beim Lesen â€“ bis zu 30% schneller!</p>

        <pre class="line-numbers"><code class="language-csharp">var bestellungen = await context.Bestellungen
    .AsNoTracking()
    .Where(b => b.Datum.Month == 12)
    .ToListAsync();</code></pre>

        <details>
            <summary>ğŸ” Warum ist AsNoTracking() schneller?</summary>
            <p>Entity Framework tracked normalerweise alle geladenen EntitÃ¤ten fÃ¼r Change Detection. Bei reinen Leseoperationen ist das unnÃ¶tig und kostet Performance. <code>AsNoTracking()</code> deaktiviert dieses Tracking.</p>
        </details>
    </div>

    <div class="content-footer">
        <p class="hint">ğŸ’¡ <strong>Tipp:</strong> Nutzen Sie Eager Loading mit <code>Include()</code> um das N+1 Problem zu vermeiden!</p>
    </div>
</div>
